#!/usr/bin/env python

# MIT License
# Copyright (c) 2024 Matt Westfall (@disloops)

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

__author__ = 'Matt Westfall'
__version__ = '0.1'
__email__ = 'disloops@gmail.com'

# This script prints an AI-generated message into a chat channel.
# It runs daily as a local cronjob:
# $ crontab -e
# --> 0 12 * * * /usr/bin/python3 /home/ubuntu/todaybot/today_bot.py
# This script depends on the Flask server generated by mush_gpt.py.

import sys
import socket
import datetime
import requests
import json
import re
import time

# MUSH connection settings
host = '[host]'
port = [port]
timeout = 0.5
bot_name = '[user]'
bot_pw = '[password]'
login = 'connect ' + bot_name + ' ' + bot_pw + '\n'

# OpenAI API settings
auth_key = "[auth value here]"
api_url = "http://localhost:5000/today"
api_timeout = 30  # seconds
max_retries = 3
retry_delay = 5  # seconds

# Message settings
message_delay = 0.5  # seconds between messages

def sanitize_message(message):
    """Sanitize the message content to be MUSH-safe"""
    # Replace Unicode quotes, dashes, and other special characters
    replacements = {
        # Unicode quotes and dashes
        '\u2013': '-',  # en dash
        '\u2014': '-',  # em dash
        '\u2018': "'",  # left single quote
        '\u2019': "'",  # right single quote
        '\u201c': '"',  # left double quote
        '\u201d': '"',  # right double quote
        '\u2012': '-',  # figure dash
        '\u2015': '-',  # horizontal bar
        '\u2017': '__', # double underscore
        '\u201a': "'",  # single low quote
        '\u201b': "'",  # single high quote
        '\u201e': '"',  # double low quote
        '\u201f': '"',  # double high quote
        '\u2026': '...', # ellipsis
        '\u2022': '*',   # bullet point

        # Control characters
        '\\n': '\n',    # literal \n
        '\\r': '\r',    # literal \r
        '\\t': ' ',     # tab
        '\\': '',       # backslash

        # Special characters
        '$': '',        # dollar sign
        '%': '',        # percent sign
        '[': '',        # left bracket
        ']': '',        # right bracket
        '#': '',        # hash
        '&': 'and',     # ampersand
        '"': '"'        # double quote
    }

    # Apply all replacements
    for old, new in replacements.items():
        message = message.replace(old, new)

    # Strip any remaining whitespace
    message = message.strip()

    return message

def get_today_message():
    """Get the +today message from the local API server"""
    print('[+] Getting +today message...')

    for attempt in range(max_retries):
        try:
            response = requests.post(
                api_url,
                json={"auth": auth_key},
                headers={"Content-Type": "application/json"},
                timeout=api_timeout
            )

            if response.status_code == 200:
                message = response.json()["message"]
                return sanitize_message(message)
            else:
                print(f"[-] Error: {response.json()['message']}")
                if attempt < max_retries - 1:
                    print(f"[*] Retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                continue

        except requests.exceptions.Timeout:
            print("[-] API request timed out")
            if attempt < max_retries - 1:
                print(f"[*] Retrying in {retry_delay} seconds...")
                time.sleep(retry_delay)
            continue
        except Exception as e:
            print(f"[-] Error connecting to API: {str(e)}")
            if attempt < max_retries - 1:
                print(f"[*] Retrying in {retry_delay} seconds...")
                time.sleep(retry_delay)
            continue

    return None

def connect():
    """Connect to the MUSH"""
    print('[+] Connecting to game...')
    try:
        game_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        game_socket.connect((host, port))
        game_socket.settimeout(timeout)
        game_socket.sendall(login.encode())
        clear_socket(game_socket)
        print(f'[*] Connected to {host}:{port} as {bot_name}.')
        return game_socket
    except socket.error as e:
        print(f"[-] Error connecting to MUSH: {str(e)}")
        return None

def clear_socket(game_socket):
    """Clear the socket buffer"""
    try:
        socket_file = game_socket.makefile(mode='rb')
        while True:
            socket_file.readline()
    except socket.timeout:
        return

def print_today(game_socket, message):
    """Print the +today message to the channel"""
    print('[-] Printing the +today message...')

    try:
        # Split message into lines and print each line
        lines = message.split('\n')
        for line in lines:
            if line.strip():  # Only print non-empty lines
                news_ticker = '@chat public=' + line + '\n'
                game_socket.sendall(news_ticker.encode())
                clear_socket(game_socket)
                time.sleep(message_delay)  # Add delay between messages

        # Log off
        game_socket.sendall('@quit\n'.encode())
        game_socket.close()

    except socket.error as e:
        print(f"[-] Error sending message: {str(e)}")
        if game_socket:
            game_socket.close()

def main():
    now = datetime.datetime.now()
    date_string = now.strftime("%B %d, %Y %H:%M:%S")
    print(f'[-] Starting Today Bot - {date_string}')

    # Get the +today message
    message = get_today_message()
    if not message:
        print('[-] Failed to get +today message')
        return 1

    # Connect to the MUSH and print the message
    game_socket = connect()
    if not game_socket:
        print('[-] Failed to connect to MUSH')
        return 1

    print_today(game_socket, message)
    print('[*] Done!')

    return 0

if __name__ == '__main__':
    sys.exit(main())
